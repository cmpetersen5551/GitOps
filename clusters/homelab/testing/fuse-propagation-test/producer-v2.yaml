---
# FUSE Producer v2 — Uses real squashfuse FUSE mount for propagation test
#
# Phase 2 test: Verifies a genuine FUSE mount (not just file writes) created
# inside a privileged container propagates to the host via Bidirectional
# hostPath, and is then visible to a non-privileged consumer via HostToContainer.
#
# squashfuse mounts a read-only squashfs image via FUSE — same kernel code path
# as Decypharr's hanwen/go-fuse mount. If this test passes, the migration
# mechanism is validated for production use.
apiVersion: v1
kind: Pod
metadata:
  name: fuse-producer-v2
  namespace: fuse-test
  labels:
    test: fuse-propagation-v2
    role: producer
spec:
  nodeName: k3s-w2
  securityContext:
    runAsUser: 0
    runAsNonRoot: false

  containers:
  - name: fuse-creator
    image: alpine:3.19
    imagePullPolicy: IfNotPresent
    securityContext:
      privileged: true
      capabilities:
        add: [SYS_ADMIN]

    command: ["/bin/sh", "-c"]
    args:
      - |
        set -e
        echo "=== Phase 2 FUSE Propagation Test (squashfuse) ==="
        apk add --no-cache squashfs-tools squashfuse fuse --quiet

        # Build a squashfs image with test files
        mkdir -p /tmp/fuse-source
        echo "hello from FUSE" > /tmp/fuse-source/regular-file.txt
        echo "nlink=0 shouldnt block POSIX reads" > /tmp/fuse-source/nlink-test.txt
        mkdir -p /tmp/fuse-source/subdir
        echo "file in subdir" > /tmp/fuse-source/subdir/nested.txt
        # Note: symlinks inside squashfs are native filesystem symlinks
        ln -s regular-file.txt /tmp/fuse-source/symlink-to-file.txt
        # Signal file
        echo "fuse-ready" > /tmp/fuse-source/ready-marker.txt

        mksquashfs /tmp/fuse-source /tmp/test.sqsh -quiet -noappend
        echo "squashfs image built: $(stat -c '%s bytes' /tmp/test.sqsh)"

        # Mount squashfuse FUSE at the hostPath volume (Bidirectional)
        echo "Mounting squashfuse at /mnt/dfs..."
        squashfuse -o allow_other /tmp/test.sqsh /mnt/dfs
        echo "Mount result: '$(mount | grep '/mnt/dfs')'"
        echo "Filesystem type via stat: $(stat -f -c '%T' /mnt/dfs 2>/dev/null || echo 'n/a')"
        echo "Files in FUSE mount: $(ls /mnt/dfs)"

        # Keep alive so mount stays active for consumer validation
        COUNT=0
        while true; do
          COUNT=$((COUNT + 1))
          echo "[$(date)] squashfuse FUSE alive, iter=$COUNT, files=$(ls /mnt/dfs | wc -l)"
          sleep 30
        done

    volumeMounts:
    - name: fuse-bridge-v2
      mountPath: /mnt/dfs
      mountPropagation: Bidirectional

    resources:
      requests:
        cpu: 100m
        memory: 128Mi
      limits:
        cpu: 500m
        memory: 256Mi

  volumes:
  - name: fuse-bridge-v2
    hostPath:
      path: /tmp/fuse-test-bridge-v2
      type: DirectoryOrCreate

  restartPolicy: OnFailure
  tolerations:
  - key: node.longhorn.io/storage
    operator: Equal
    value: enabled
    effect: NoSchedule
