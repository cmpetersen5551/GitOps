apiVersion: v1
kind: ConfigMap
metadata:
  name: volume-fencing-script
  namespace: kube-system
data:
  fence.py: |
    import os
    import sys
    from datetime import datetime, timezone

    from kubernetes import client, config

    NODE_NOTREADY_SECONDS = int(os.getenv("NODE_NOTREADY_SECONDS", "600"))
    STORAGE_CLASSES = set(
        sc.strip() for sc in os.getenv("STORAGE_CLASSES", "seaweedfs-storage").split(",")
        if sc.strip()
    )
    DRY_RUN = os.getenv("DRY_RUN", "false").lower() == "true"

    def log(message: str) -> None:
        print(message, flush=True)

    def load_config() -> None:
        try:
            config.load_incluster_config()
        except Exception as exc:
            log(f"Failed to load in-cluster config: {exc}")
            sys.exit(1)

    def node_notready_since(node) -> int:
        for cond in node.status.conditions or []:
            if cond.type == "Ready" and cond.status != "True":
                last = cond.last_transition_time
                if not last:
                    return 0
                now = datetime.now(timezone.utc)
                return int((now - last).total_seconds())
        return 0

    def main() -> None:
        load_config()
        core = client.CoreV1Api()
        storage = client.StorageV1Api()

        dead_nodes = {}
        for node in core.list_node().items:
            seconds = node_notready_since(node)
            if seconds >= NODE_NOTREADY_SECONDS:
                dead_nodes[node.metadata.name] = seconds

        if not dead_nodes:
            log("No NotReady nodes past threshold. Exiting.")
            return

        pods_by_pvc = {}
        for pod in core.list_pod_for_all_namespaces().items:
            if pod.status.phase != "Pending":
                continue
            for vol in pod.spec.volumes or []:
                if not vol.persistent_volume_claim:
                    continue
                key = f"{pod.metadata.namespace}/{vol.persistent_volume_claim.claim_name}"
                pods_by_pvc.setdefault(key, []).append(pod)

        for va in storage.list_volume_attachment().items:
            node_name = va.spec.node_name
            if node_name not in dead_nodes:
                continue
            # Target both attached and unattached (stuck) VolumeAttachments
            if va.status and va.status.attached:
                log_status = "attached=true"
            else:
                log_status = "attached=false (stuck)"
            pv_name = va.spec.source.persistent_volume_name
            if not pv_name:
                continue

            pv = core.read_persistent_volume(pv_name)
            scn = pv.spec.storage_class_name or ""
            if scn not in STORAGE_CLASSES:
                continue

            claim_ref = pv.spec.claim_ref
            if not claim_ref:
                continue
            pvc_key = f"{claim_ref.namespace}/{claim_ref.name}"
            pending_pods = pods_by_pvc.get(pvc_key, [])
            if not pending_pods:
                log(
                    f"Skip VA {va.metadata.name}: no pending pod for {pvc_key}"
                )
                continue

            log(
                "Fencing volume: VA="
                f"{va.metadata.name} pv={pv_name} pvc={pvc_key} "
                f"node={node_name} notready_seconds={dead_nodes[node_name]} "
                f"status={log_status}"
            )
            if DRY_RUN:
                log("Dry run enabled. Skipping delete.")
                continue

            storage.delete_volume_attachment(va.metadata.name)
            log(f"Deleted VolumeAttachment {va.metadata.name}")

    if __name__ == "__main__":
        main()
