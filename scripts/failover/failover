#!/usr/bin/env python3
"""
GitOps Failover Script
Automated failover/failback for HA services by editing Git manifests

Non-interactive: Pass action only (promote or demote)
Usage: ./scripts/failover <promote|demote>

Example:
  ./scripts/failover promote      # Failover to backup
  ./scripts/failover demote       # Failback to primary

Services are configured in scripts/failover.json
"""

import os
import sys
import json
import subprocess
import shutil
from pathlib import Path
from typing import Dict, Optional

class Colors:
    OKGREEN = '\033[92m'
    FAIL = '\033[91m'
    WARNING = '\033[93m'
    ENDC = '\033[0m'

def log(msg: str, level: str = "info"):
    """Log messages with color coding"""
    if level == "error":
        print(f"{Colors.FAIL}✗ {msg}{Colors.ENDC}", file=sys.stderr)
    elif level == "success":
        print(f"{Colors.OKGREEN}✓ {msg}{Colors.ENDC}")
    elif level == "warning":
        print(f"{Colors.WARNING}⚠ {msg}{Colors.ENDC}")
    else:
        print(f"→ {msg}")

def load_services_config() -> Dict:
    """Load services configuration from JSON file"""
    config_path = Path(__file__).parent / "failover.json"
    
    if not config_path.exists():
        log(f"Config file not found: {config_path}", "error")
        sys.exit(1)
    
    try:
        with open(config_path, 'r') as f:
            config = json.load(f)
    except json.JSONDecodeError as e:
        log(f"Invalid JSON in {config_path}: {e}", "error")
        sys.exit(1)
    
    if not config or 'services' not in config:
        log("Invalid config: 'services' key not found", "error")
        sys.exit(1)
    
    return config['services']

def get_deployment_path(service_config: Dict) -> str:
    """Generate deployment file path from config"""
    namespace = service_config.get('namespace')
    deployment = service_config.get('deployment')
    return f"clusters/homelab/apps/{namespace}/{deployment}/deployment.yaml"

def edit_with_yq(file_path: str, volume_name: str, new_pvc: str, new_role: str) -> bool:
    """Edit YAML file using yq (if available)"""
    try:
        subprocess.run(['which', 'yq'], check=True, capture_output=True)
        
        cmd1 = f"yq -i '.spec.template.spec.volumes[] | select(.name == \"{volume_name}\").persistentVolumeClaim.claimName = \"{new_pvc}\"' {file_path}"
        cmd2 = f"yq -i '.spec.template.spec.nodeSelector.role = \"{new_role}\"' {file_path}"
        
        subprocess.run(cmd1, shell=True, check=True, capture_output=True)
        subprocess.run(cmd2, shell=True, check=True, capture_output=True)
        
        return True
    except (subprocess.CalledProcessError, FileNotFoundError):
        return False

def edit_with_sed(file_path: str, old_pvc: str, new_pvc: str, new_role: str) -> bool:
    """Edit YAML file using sed (fallback)"""
    try:
        backup_path = f"{file_path}.bak"
        shutil.copy(file_path, backup_path)
        
        # Use safer sed approach with delimiters
        cmd1 = f"sed -i.bak 's|claimName: {old_pvc}|claimName: {new_pvc}|' {file_path}"
        cmd2 = f"sed -i.bak 's|role: [a-z]*|role: {new_role}|' {file_path}"
        
        subprocess.run(cmd1, shell=True, check=True)
        subprocess.run(cmd2, shell=True, check=True)
        
        if Path(f"{file_path}.bak").exists():
            os.remove(f"{file_path}.bak")
        
        return True
    except subprocess.CalledProcessError:
        if Path(backup_path).exists():
            shutil.copy(backup_path, file_path)
            os.remove(backup_path)
        return False

def edit_deployment(
    file_path: str,
    volume_name: str,
    old_pvc: str,
    new_pvc: str,
    new_role: str
) -> bool:
    """Edit deployment manifest with new PVC and role"""
    file_abs = Path(__file__).resolve().parent.parent.parent / file_path
    
    if not file_abs.exists():
        log(f"Deployment not found: {file_abs}", "error")
        return False
    
    log(f"Editing: {file_path}")
    
    if not edit_with_yq(str(file_abs), volume_name, new_pvc, new_role):
        log("Using sed for YAML edit", "warning")
        if not edit_with_sed(str(file_abs), old_pvc, new_pvc, new_role):
            log("Failed to edit deployment", "error")
            return False
    
    return True

def git_commit_and_push(service: str, action: str) -> bool:
    """Commit and push changes to Git"""
    repo_root = Path(__file__).resolve().parent.parent.parent
    
    try:
        os.chdir(repo_root)
        
        log("Staging changes...")
        subprocess.run(['git', 'add', '-A'], check=True, capture_output=True)
        
        action_desc = "failover to backup" if action == "promote" else "failback to primary"
        commit_msg = f"failover: {service} - {action_desc}"
        
        log(f"Committing: {commit_msg}")
        subprocess.run(['git', 'commit', '-m', commit_msg], check=True, capture_output=True)
        
        log("Pushing to GitHub...")
        result = subprocess.run(['git', 'push'], capture_output=True, text=True)
        
        if result.returncode != 0:
            log(f"Push failed: {result.stderr}", "error")
            return False
        
        log("Changes pushed successfully", "success")
        return True
    
    except subprocess.CalledProcessError as e:
        log(f"Git operation failed: {e}", "error")
        return False

def main():
    # Parse arguments - only action required
    if len(sys.argv) < 2:
        print(f"Usage: {sys.argv[0]} <promote|demote>", file=sys.stderr)
        print(f"Example: {sys.argv[0]} promote", file=sys.stderr)
        sys.exit(1)
    
    action = sys.argv[1]
    
    if action not in ['promote', 'demote']:
        log(f"Invalid action: {action}. Must be 'promote' or 'demote'", "error")
        sys.exit(1)
    
    # Load configuration
    log("Loading services configuration...")
    services = load_services_config()
    
    # For now, failover the first service (in a real scenario, you might prompt or auto-detect)
    # This is simple: script handles one configured service at a time
    if len(services) == 0:
        log("No services configured in failover.json", "error")
        sys.exit(1)
    
    service_name = list(services.keys())[0]
    service_config = services[service_name]
    
    log(f"Starting failover operation: {service_name} → {action}")
    
    # Determine failover direction
    if action == "promote":
        source_pvc = service_config.get('primary_pvc')
        target_pvc = service_config.get('backup_pvc')
        target_role = service_config.get('backup_node_label')
        source_node = service_config.get('primary_node_label')
        target_node = service_config.get('backup_node_label')
    else:  # demote
        source_pvc = service_config.get('backup_pvc')
        target_pvc = service_config.get('primary_pvc')
        target_role = service_config.get('primary_node_label')
        source_node = service_config.get('backup_node_label')
        target_node = service_config.get('primary_node_label')
    
    log(f"Service: {service_name} (namespace: {service_config.get('namespace')})")
    log(f"Failover: {source_node} → {target_node}")
    log(f"PVC: {source_pvc} → {target_pvc}")
    
    # Edit deployment
    deployment_path = get_deployment_path(service_config)
    volume_name = service_config.get('volume_name')
    
    if not edit_deployment(deployment_path, volume_name, source_pvc, target_pvc, target_role):
        log("Failed to edit deployment", "error")
        sys.exit(1)
    
    # Commit and push
    if not git_commit_and_push(service_name, action):
        log("Failed to commit and push", "error")
        sys.exit(1)
    
    log("✓ Failover triggered successfully!", "success")
    log("Flux will reconcile within 1 minute")
    log(f"Monitor with: kubectl get pods -n {service_config.get('namespace')} -o wide --watch")

if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        log("\nInterrupted by user", "warning")
        sys.exit(0)
    except Exception as e:
        log(f"Unexpected error: {e}", "error")
        sys.exit(1)
