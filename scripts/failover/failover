#!/usr/bin/env python3
"""
GitOps Failover Script
Automated failover/failback for HA services by editing Git manifests

Non-interactive: Pass action only (promote or demote)
Usage: ./scripts/failover <promote|demote>

Example:
  ./scripts/failover promote      # Failover to backup
  ./scripts/failover demote       # Failback to primary

Services are configured in scripts/failover.json
"""

import os
import sys
import json
import subprocess
import shutil
from pathlib import Path
from typing import Dict, Optional

class Colors:
    OKGREEN = '\033[92m'
    FAIL = '\033[91m'
    WARNING = '\033[93m'
    ENDC = '\033[0m'

def log(msg: str, level: str = "info"):
    """Log messages with color coding"""
    if level == "error":
        print(f"{Colors.FAIL}✗ {msg}{Colors.ENDC}", file=sys.stderr)
    elif level == "success":
        print(f"{Colors.OKGREEN}✓ {msg}{Colors.ENDC}")
    elif level == "warning":
        print(f"{Colors.WARNING}⚠ {msg}{Colors.ENDC}")
    else:
        print(f"→ {msg}")

# When debugging, set this to True to prevent any git commit/push operations.
# This is intentionally conservative while we iterate on failover behavior.
DISABLE_COMMIT = False

def load_services_config() -> Dict:
    """Load services configuration from JSON file"""
    config_path = Path(__file__).parent / "failover.json"
    
    if not config_path.exists():
        log(f"Config file not found: {config_path}", "error")
        sys.exit(1)
    
    try:
        with open(config_path, 'r') as f:
            config = json.load(f)
    except json.JSONDecodeError as e:
        log(f"Invalid JSON in {config_path}: {e}", "error")
        sys.exit(1)
    
    if not config or 'services' not in config:
        log("Invalid config: 'services' key not found", "error")
        sys.exit(1)
    
    return config['services']

def get_deployment_path(service_config: Dict) -> str:
    """Generate deployment file path from config"""
    namespace = service_config.get('namespace')
    deployment = service_config.get('deployment')
    return f"clusters/homelab/apps/{namespace}/{deployment}/deployment.yaml"

def edit_with_yq(file_path: str, volume_name: str, new_pvc: str, new_role: str) -> bool:
    """Edit YAML file using yq (if available)
    
    Sets the claimName to the exact target value, not string replacement.
    """
    try:
        subprocess.run(['which', 'yq'], check=True, capture_output=True)
        
        # Set exact value for claimName (not string replacement)
        cmd1 = f"yq -i '.spec.template.spec.volumes[] | select(.name == \"{volume_name}\").persistentVolumeClaim.claimName = \"{new_pvc}\"' {file_path}"
        cmd2 = f"yq -i '.spec.template.spec.nodeSelector.role = \"{new_role}\"' {file_path}"
        
        subprocess.run(cmd1, shell=True, check=True, capture_output=True)
        subprocess.run(cmd2, shell=True, check=True, capture_output=True)
        
        return True
    except (subprocess.CalledProcessError, FileNotFoundError):
        return False

def edit_with_python(file_path: str, new_pvc: str, new_role: str) -> bool:
    """Edit YAML file using Python (fallback when yq unavailable)
    
    Reads the file, finds claimName and role lines, and replaces them with exact values.
    This avoids substring matching issues that sed has.
    """
    try:
        backup_path = f"{file_path}.bak"
        shutil.copy(file_path, backup_path)
        
        with open(file_path, 'r') as f:
            lines = f.readlines()
        
        modified = False
        for i, line in enumerate(lines):
            # Replace claimName line with exact value
            if 'claimName:' in line:
                indent = len(line) - len(line.lstrip())
                lines[i] = ' ' * indent + f'claimName: {new_pvc}\n'
                modified = True
            # Replace role line with exact value
            elif line.strip().startswith('role:'):
                indent = len(line) - len(line.lstrip())
                lines[i] = ' ' * indent + f'role: {new_role}\n'
                modified = True
        
        if modified:
            with open(file_path, 'w') as f:
                f.writelines(lines)
        
        # Clean up backup
        if Path(backup_path).exists():
            os.remove(backup_path)
        
        return True
    except Exception as e:
        log(f"Python edit failed: {e}", "error")
        # Restore from backup
        if Path(backup_path).exists():
            shutil.copy(backup_path, file_path)
            os.remove(backup_path)
        return False

def edit_deployment(
    file_path: str,
    volume_name: str,
    old_pvc: str,
    new_pvc: str,
    new_role: str
) -> bool:
    """Edit deployment manifest with new PVC and role
    
    This function:
    1. Reads current claimName from the deployment
    2. Checks if already at target state (skip if so)
    3. Sets claimName to exact target value (no string replacement)
    """
    file_abs = Path(__file__).resolve().parent.parent.parent / file_path
    
    if not file_abs.exists():
        log(f"Deployment not found: {file_abs}", "error")
        return False
    
    # Read current state
    try:
        with open(file_abs, 'r') as fh:
            content = fh.readlines()
    except Exception as e:
        log(f"Failed to read deployment file: {e}", "error")
        return False

    current_claim = None
    current_role = None
    
    # Parse current claimName and role
    for idx, line in enumerate(content):
        # Find claimName
        if 'claimName:' in line:
            parts = line.split(':', 1)
            if len(parts) > 1:
                current_claim = parts[1].strip().strip(' "\'')
        # Find role
        if line.strip().startswith('role:'):
            parts = line.split(':', 1)
            if len(parts) > 1:
                current_role = parts[1].strip().strip(' "\'')

    # Check if already at target state
    if current_claim == new_pvc and current_role == new_role:
        log(f"Already at target state (PVC: {new_pvc}, role: {new_role}); skipping")
        return True
    
    log(f"Editing: {file_path}")
    log(f"  Current: claimName={current_claim}, role={current_role}")
    log(f"  Target:  claimName={new_pvc}, role={new_role}")

    # Attempt edit with yq first, fall back to Python-based edit
    if not edit_with_yq(str(file_abs), volume_name, new_pvc, new_role):
        log("yq not available, using Python-based YAML edit", "warning")
        if not edit_with_python(str(file_abs), new_pvc, new_role):
            log("Failed to edit deployment", "error")
            return False
    
    return True

def git_commit_and_push(services: list, action: str, files_to_commit: Optional[list] = None) -> bool:
    """Commit and push changes to Git for multiple services.

    `files_to_commit` is a list of repo-relative file paths to commit. Only these
    paths will be staged/committed to avoid including unrelated changes.
    """
    repo_root = Path(__file__).resolve().parent.parent.parent

    try:
        os.chdir(repo_root)

        action_desc = "failover to backup" if action == "promote" else "failback to primary"
        svc_list = ','.join(services)
        commit_msg = f"failover: {svc_list} - {action_desc}"

        if DISABLE_COMMIT:
            # Debug mode: do not perform any git operations. Log intended actions instead.
            log("Commit/push operations are DISABLED (debug mode).", "warning")
            if files_to_commit:
                log(f"Would stage {len(files_to_commit)} file(s): {', '.join(files_to_commit)}")
            else:
                log("Would stage all changes (no specific files listed)")
            log(f"Would commit with message: {commit_msg}")
            log("Skipping push to remote.")
            return True

        if not files_to_commit:
            log("Staging changes... (no specific files provided, staging all)")
            subprocess.run(['git', 'add', '-A'], check=True, capture_output=True)
            commit_cmd = ['git', 'commit', '-m', commit_msg]
        else:
            # stage only the specified files
            log(f"Staging {len(files_to_commit)} deployment file(s)...")
            for p in files_to_commit:
                subprocess.run(['git', 'add', p], check=True, capture_output=True)
            # commit only those paths to be safe
            commit_cmd = ['git', 'commit', '-m', commit_msg, '--'] + files_to_commit

        log(f"Committing: {commit_msg}")
        commit = subprocess.run(commit_cmd, capture_output=True, text=True)
        if commit.returncode != 0:
            # No changes to commit is not fatal
            out = (commit.stderr or commit.stdout or '').lower()
            if 'nothing to commit' in out:
                log("No changes to commit", "warning")
                return True
            else:
                log(f"Commit failed: {commit.stderr or commit.stdout}", "error")
                return False

        log("Pushing to GitHub...")
        result = subprocess.run(['git', 'push'], capture_output=True, text=True)

        if result.returncode != 0:
            log(f"Push failed: {result.stderr}", "error")
            return False

        log("Changes pushed successfully", "success")
        return True

    except subprocess.CalledProcessError as e:
        log(f"Git operation failed: {e}", "error")
        return False

def main():
    # Parse arguments - only action required
    if len(sys.argv) < 2:
        print(f"Usage: {sys.argv[0]} <promote|demote>", file=sys.stderr)
        print(f"Example: {sys.argv[0]} promote", file=sys.stderr)
        sys.exit(1)
    
    action = sys.argv[1]
    
    if action not in ['promote', 'demote']:
        log(f"Invalid action: {action}. Must be 'promote' or 'demote'", "error")
        sys.exit(1)
    
    # Load configuration
    log("Loading services configuration...")
    services = load_services_config()
    
    # Decide which services to operate on: specific service or all
    if len(services) == 0:
        log("No services configured in failover.json", "error")
        sys.exit(1)

    service_arg: Optional[str] = None
    if len(sys.argv) >= 3:
        service_arg = sys.argv[2]

    if service_arg:
        if service_arg == 'all':
            target_services = list(services.keys())
        elif service_arg in services:
            target_services = [service_arg]
        else:
            log(f"Unknown service: {service_arg}", "error")
            sys.exit(1)
    else:
        # default to all services
        target_services = list(services.keys())

    log(f"Starting failover operation: {','.join(target_services)} → {action}")

    succeeded = []
    failed = []

    for svc in target_services:
        service_config = services[svc]

        # Determine failover direction per-service
        if action == "promote":
            source_pvc = service_config.get('primary_pvc')
            target_pvc = service_config.get('backup_pvc')
            target_role = service_config.get('backup_node_label')
            source_node = service_config.get('primary_node_label')
            target_node = service_config.get('backup_node_label')
        else:  # demote
            source_pvc = service_config.get('backup_pvc')
            target_pvc = service_config.get('primary_pvc')
            target_role = service_config.get('primary_node_label')
            source_node = service_config.get('backup_node_label')
            target_node = service_config.get('primary_node_label')

        log(f"Service: {svc} (namespace: {service_config.get('namespace')})")
        log(f"Failover: {source_node} → {target_node}")
        log(f"PVC: {source_pvc} → {target_pvc}")

        # Edit deployment
        deployment_path = get_deployment_path(service_config)
        volume_name = service_config.get('volume_name')

        if edit_deployment(deployment_path, volume_name, source_pvc, target_pvc, target_role):
            succeeded.append(svc)
        else:
            failed.append(svc)

    if len(succeeded) == 0:
        log("No services were successfully edited; aborting commit", "error")
        if failed:
            log(f"Failed services: {','.join(failed)}", "error")
        sys.exit(1)

    # Commit and push successes together. Only commit the deployment files we edited.
    repo_root = Path(__file__).resolve().parent.parent.parent
    files_to_commit = []
    for svc in succeeded:
        svc_cfg = services[svc]
        files_to_commit.append(str((repo_root / get_deployment_path(svc_cfg)).as_posix()))

    # Convert to repo-relative paths for git
    files_to_commit = [str(Path(p).relative_to(repo_root)) for p in files_to_commit]

    if not git_commit_and_push(succeeded, action, files_to_commit):
        log("Failed to commit and push", "error")
        sys.exit(1)

    log("✓ Failover triggered successfully!", "success")
    log("Flux will reconcile within 1 minute")
    # show namespaces for succeeded services (unique namespaces)
    namespaces = sorted(set(services[s].get('namespace') for s in succeeded))
    for ns in namespaces:
        log(f"Monitor with: kubectl get pods -n {ns} -o wide --watch")

if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        log("\nInterrupted by user", "warning")
        sys.exit(0)
    except Exception as e:
        log(f"Unexpected error: {e}", "error")
        sys.exit(1)
