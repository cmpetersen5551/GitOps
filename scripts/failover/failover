#!/usr/bin/env python3
"""
GitOps Failover Script
Automated failover/failback for HA services by editing Git manifests

Non-interactive: Pass action only (promote or demote)
Usage: ./scripts/failover <promote|demote>

Example:
  ./scripts/failover promote      # Failover to backup
  ./scripts/failover demote       # Failback to primary

Services are configured in scripts/failover.json
"""

import os
import sys
import json
import subprocess
import shutil
from pathlib import Path
from typing import Dict, Optional

class Colors:
    OKGREEN = '\033[92m'
    FAIL = '\033[91m'
    WARNING = '\033[93m'
    ENDC = '\033[0m'

def log(msg: str, level: str = "info"):
    """Log messages with color coding"""
    if level == "error":
        print(f"{Colors.FAIL}✗ {msg}{Colors.ENDC}", file=sys.stderr)
    elif level == "success":
        print(f"{Colors.OKGREEN}✓ {msg}{Colors.ENDC}")
    elif level == "warning":
        print(f"{Colors.WARNING}⚠ {msg}{Colors.ENDC}")
    else:
        print(f"→ {msg}")

def load_services_config() -> Dict:
    """Load services configuration from JSON file"""
    config_path = Path(__file__).parent / "failover.json"
    
    if not config_path.exists():
        log(f"Config file not found: {config_path}", "error")
        sys.exit(1)
    
    try:
        with open(config_path, 'r') as f:
            config = json.load(f)
    except json.JSONDecodeError as e:
        log(f"Invalid JSON in {config_path}: {e}", "error")
        sys.exit(1)
    
    if not config or 'services' not in config:
        log("Invalid config: 'services' key not found", "error")
        sys.exit(1)
    
    return config['services']

def get_deployment_path(service_config: Dict) -> str:
    """Generate deployment file path from config"""
    namespace = service_config.get('namespace')
    deployment = service_config.get('deployment')
    return f"clusters/homelab/apps/{namespace}/{deployment}/deployment.yaml"

def edit_with_yq(file_path: str, volume_name: str, new_pvc: str, new_role: str) -> bool:
    """Edit YAML file using yq (if available)"""
    try:
        subprocess.run(['which', 'yq'], check=True, capture_output=True)
        
        cmd1 = f"yq -i '.spec.template.spec.volumes[] | select(.name == \"{volume_name}\").persistentVolumeClaim.claimName = \"{new_pvc}\"' {file_path}"
        cmd2 = f"yq -i '.spec.template.spec.nodeSelector.role = \"{new_role}\"' {file_path}"
        
        subprocess.run(cmd1, shell=True, check=True, capture_output=True)
        subprocess.run(cmd2, shell=True, check=True, capture_output=True)
        
        return True
    except (subprocess.CalledProcessError, FileNotFoundError):
        return False

def edit_with_sed(file_path: str, old_pvc: str, new_pvc: str, new_role: str) -> bool:
    """Edit YAML file using sed (fallback)"""
    try:
        backup_path = f"{file_path}.bak"
        shutil.copy(file_path, backup_path)
        
        # Use safer sed approach with delimiters
        cmd1 = f"sed -i.bak 's|claimName: {old_pvc}|claimName: {new_pvc}|' {file_path}"
        cmd2 = f"sed -i.bak 's|role: [a-z]*|role: {new_role}|' {file_path}"
        
        subprocess.run(cmd1, shell=True, check=True)
        subprocess.run(cmd2, shell=True, check=True)
        
        if Path(f"{file_path}.bak").exists():
            os.remove(f"{file_path}.bak")
        
        return True
    except subprocess.CalledProcessError:
        if Path(backup_path).exists():
            shutil.copy(backup_path, file_path)
            os.remove(backup_path)
        return False

def edit_deployment(
    file_path: str,
    volume_name: str,
    old_pvc: str,
    new_pvc: str,
    new_role: str
) -> bool:
    """Edit deployment manifest with new PVC and role"""
    file_abs = Path(__file__).resolve().parent.parent.parent / file_path
    
    if not file_abs.exists():
        log(f"Deployment not found: {file_abs}", "error")
        return False
    
    log(f"Editing: {file_path}")
    
    if not edit_with_yq(str(file_abs), volume_name, new_pvc, new_role):
        log("Using sed for YAML edit", "warning")
        if not edit_with_sed(str(file_abs), old_pvc, new_pvc, new_role):
            log("Failed to edit deployment", "error")
            return False
    
    return True

def git_commit_and_push(services: list, action: str) -> bool:
    """Commit and push changes to Git for multiple services."""
    repo_root = Path(__file__).resolve().parent.parent.parent

    try:
        os.chdir(repo_root)

        log("Staging changes...")
        subprocess.run(['git', 'add', '-A'], check=True, capture_output=True)

        action_desc = "failover to backup" if action == "promote" else "failback to primary"
        svc_list = ','.join(services)
        commit_msg = f"failover: {svc_list} - {action_desc}"

        log(f"Committing: {commit_msg}")
        # If there are no changes, git commit will exit non-zero; capture that case
        commit = subprocess.run(['git', 'commit', '-m', commit_msg], capture_output=True, text=True)
        if commit.returncode != 0:
            # No changes to commit is not fatal if message indicates nothing changed
            if 'nothing to commit' in commit.stderr.lower() or 'nothing to commit' in commit.stdout.lower():
                log("No changes to commit", "warning")
                return True
            else:
                log(f"Commit failed: {commit.stderr or commit.stdout}", "error")
                return False

        log("Pushing to GitHub...")
        result = subprocess.run(['git', 'push'], capture_output=True, text=True)

        if result.returncode != 0:
            log(f"Push failed: {result.stderr}", "error")
            return False

        log("Changes pushed successfully", "success")
        return True

    except subprocess.CalledProcessError as e:
        log(f"Git operation failed: {e}", "error")
        return False

def main():
    # Parse arguments - only action required
    if len(sys.argv) < 2:
        print(f"Usage: {sys.argv[0]} <promote|demote>", file=sys.stderr)
        print(f"Example: {sys.argv[0]} promote", file=sys.stderr)
        sys.exit(1)
    
    action = sys.argv[1]
    
    if action not in ['promote', 'demote']:
        log(f"Invalid action: {action}. Must be 'promote' or 'demote'", "error")
        sys.exit(1)
    
    # Load configuration
    log("Loading services configuration...")
    services = load_services_config()
    
    # Decide which services to operate on: specific service or all
    if len(services) == 0:
        log("No services configured in failover.json", "error")
        sys.exit(1)

    service_arg: Optional[str] = None
    if len(sys.argv) >= 3:
        service_arg = sys.argv[2]

    if service_arg:
        if service_arg == 'all':
            target_services = list(services.keys())
        elif service_arg in services:
            target_services = [service_arg]
        else:
            log(f"Unknown service: {service_arg}", "error")
            sys.exit(1)
    else:
        # default to all services
        target_services = list(services.keys())

    log(f"Starting failover operation: {','.join(target_services)} → {action}")

    succeeded = []
    failed = []

    for svc in target_services:
        service_config = services[svc]

        # Determine failover direction per-service
        if action == "promote":
            source_pvc = service_config.get('primary_pvc')
            target_pvc = service_config.get('backup_pvc')
            target_role = service_config.get('backup_node_label')
            source_node = service_config.get('primary_node_label')
            target_node = service_config.get('backup_node_label')
        else:  # demote
            source_pvc = service_config.get('backup_pvc')
            target_pvc = service_config.get('primary_pvc')
            target_role = service_config.get('primary_node_label')
            source_node = service_config.get('backup_node_label')
            target_node = service_config.get('primary_node_label')

        log(f"Service: {svc} (namespace: {service_config.get('namespace')})")
        log(f"Failover: {source_node} → {target_node}")
        log(f"PVC: {source_pvc} → {target_pvc}")

        # Edit deployment
        deployment_path = get_deployment_path(service_config)
        volume_name = service_config.get('volume_name')

        if edit_deployment(deployment_path, volume_name, source_pvc, target_pvc, target_role):
            succeeded.append(svc)
        else:
            failed.append(svc)

    if len(succeeded) == 0:
        log("No services were successfully edited; aborting commit", "error")
        if failed:
            log(f"Failed services: {','.join(failed)}", "error")
        sys.exit(1)

    # Commit and push successes together
    if not git_commit_and_push(succeeded, action):
        log("Failed to commit and push", "error")
        sys.exit(1)

    log("✓ Failover triggered successfully!", "success")
    log("Flux will reconcile within 1 minute")
    # show namespaces for succeeded services (unique namespaces)
    namespaces = sorted(set(services[s].get('namespace') for s in succeeded))
    for ns in namespaces:
        log(f"Monitor with: kubectl get pods -n {ns} -o wide --watch")

if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        log("\nInterrupted by user", "warning")
        sys.exit(0)
    except Exception as e:
        log(f"Unexpected error: {e}", "error")
        sys.exit(1)
