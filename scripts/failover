#!/usr/bin/env python3
"""
GitOps Failover Script
Triggers failover/failback for HA services by editing Git manifests
No external dependencies - works with standard library + PyYAML (if installed)
Falls back to sed if PyYAML not available
"""

import os
import sys
import json
import subprocess
import tempfile
import shutil
from pathlib import Path
from typing import Dict, List, Optional

# Colors for output
class Colors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKCYAN = '\033[96m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

def log(msg: str, level: str = "info"):
    """Log messages with color coding"""
    if level == "error":
        print(f"{Colors.FAIL}✗ {msg}{Colors.ENDC}")
    elif level == "success":
        print(f"{Colors.OKGREEN}✓ {msg}{Colors.ENDC}")
    elif level == "warning":
        print(f"{Colors.WARNING}⚠ {msg}{Colors.ENDC}")
    elif level == "header":
        print(f"{Colors.BOLD}{Colors.HEADER}{msg}{Colors.ENDC}")
    else:
        print(f"{Colors.OKCYAN}→ {msg}{Colors.ENDC}")

def load_services_config() -> Dict:
    """Load services configuration from ConfigMap YAML"""
    config_path = Path(__file__).parent.parent / "clusters/homelab/operations/failover-api/configmap.yaml"
    
    if not config_path.exists():
        log(f"Config file not found: {config_path}", "error")
        sys.exit(1)
    
    try:
        # Try importing PyYAML for proper parsing
        import yaml
        with open(config_path, 'r') as f:
            content = f.read()
            # Extract the services.yaml data section
            start = content.find('services.yaml: |')
            if start == -1:
                log("Could not find 'services.yaml' section in ConfigMap", "error")
                sys.exit(1)
            services_yaml = content[start + len('services.yaml: |'):]
            config = yaml.safe_load(services_yaml)
    except ImportError:
        # Fallback to manual parsing
        log("PyYAML not installed, using fallback parser", "warning")
        config = _parse_yaml_fallback(config_path)
    
    if not config or 'services' not in config:
        log("Invalid config: 'services' key not found", "error")
        sys.exit(1)
    
    return config['services']

def _parse_yaml_fallback(config_path: Path) -> Dict:
    """Fallback YAML parser for when PyYAML is not available"""
    services = {}
    current_service = None
    
    with open(config_path, 'r') as f:
        in_services = False
        for line in f:
            line = line.rstrip()
            
            if 'services:' in line:
                in_services = True
                continue
            
            if not in_services or not line.strip():
                continue
            
            # Service name (no leading spaces, ends with colon)
            if line and line[0] not in ' #':
                continue
            
            # Check if this is a service entry (2-space indent, not starting with #)
            if line.startswith('  ') and not line.startswith('    ') and not line.strip().startswith('#'):
                service_name = line.strip().rstrip(':')
                if service_name:
                    current_service = service_name
                    services[current_service] = {}
            
            # Service properties (4-space indent)
            elif line.startswith('    ') and ':' in line and current_service:
                parts = line.strip().split(':', 1)
                key = parts[0].strip()
                value = parts[1].strip()
                services[current_service][key] = value
    
    return {'services': services}

def get_deployment_path(service_config: Dict) -> str:
    """Generate deployment file path from config"""
    namespace = service_config.get('namespace')
    deployment = service_config.get('deployment')
    return f"clusters/homelab/apps/{namespace}/{deployment}/deployment.yaml"

def edit_with_yq(file_path: str, volume_name: str, new_pvc: str, new_role: str) -> bool:
    """Edit YAML file using yq (if available)"""
    try:
        # Check if yq is available
        subprocess.run(['which', 'yq'], check=True, capture_output=True)
        
        # Edit volume
        cmd1 = f"yq -i '.spec.template.spec.volumes[] | select(.name == \"{volume_name}\").persistentVolumeClaim.claimName = \"{new_pvc}\"' {file_path}"
        # Edit nodeSelector
        cmd2 = f"yq -i '.spec.template.spec.nodeSelector.role = \"{new_role}\"' {file_path}"
        
        subprocess.run(cmd1, shell=True, check=True, capture_output=True)
        subprocess.run(cmd2, shell=True, check=True, capture_output=True)
        
        return True
    except (subprocess.CalledProcessError, FileNotFoundError):
        return False

def edit_with_sed(file_path: str, volume_name: str, old_pvc: str, new_pvc: str, new_role: str) -> bool:
    """Edit YAML file using sed (fallback)"""
    try:
        # Create backup
        backup_path = f"{file_path}.bak"
        shutil.copy(file_path, backup_path)
        
        # Replace PVC claim
        cmd1 = f"sed -i.bak 's/claimName: {old_pvc}/claimName: {new_pvc}/' {file_path}"
        # Replace role
        cmd2 = f"sed -i.bak 's/role: [a-z]*/role: {new_role}/' {file_path}"
        
        subprocess.run(cmd1, shell=True, check=True)
        subprocess.run(cmd2, shell=True, check=True)
        
        # Remove backup
        if Path(f"{file_path}.bak").exists():
            os.remove(f"{file_path}.bak")
        
        return True
    except subprocess.CalledProcessError:
        # Restore backup on failure
        if Path(backup_path).exists():
            shutil.copy(backup_path, file_path)
            os.remove(backup_path)
        return False

def edit_deployment(
    file_path: str,
    volume_name: str,
    old_pvc: str,
    new_pvc: str,
    new_role: str
) -> bool:
    """Edit deployment manifest with new PVC and role"""
    file_abs = Path(__file__).parent.parent / file_path
    
    if not file_abs.exists():
        log(f"Deployment not found: {file_abs}", "error")
        return False
    
    log(f"Editing: {file_path}")
    log(f"  Volume: {volume_name}")
    log(f"  PVC: {old_pvc} → {new_pvc}")
    log(f"  Role: primary → {new_role}")
    
    # Try yq first (more reliable), fall back to sed
    if not edit_with_yq(str(file_abs), volume_name, new_pvc, new_role):
        log("yq not available, using sed", "warning")
        if not edit_with_sed(str(file_abs), volume_name, old_pvc, new_pvc, new_role):
            log("Failed to edit deployment with sed", "error")
            return False
    
    return True

def git_commit_and_push(service: str, action: str) -> bool:
    """Commit and push changes to Git"""
    repo_root = Path(__file__).parent.parent
    
    try:
        # Change to repo root
        os.chdir(repo_root)
        
        log("Staging changes...")
        subprocess.run(['git', 'add', '-A'], check=True, capture_output=True)
        
        action_desc = "failover to backup" if action == "promote" else "failback to primary"
        commit_msg = f"failover: {service} - {action_desc}"
        
        log(f"Committing: {commit_msg}")
        subprocess.run(['git', 'commit', '-m', commit_msg], check=True, capture_output=True)
        
        log("Pushing to GitHub...")
        result = subprocess.run(['git', 'push'], capture_output=True, text=True)
        
        if result.returncode != 0:
            log(f"Push failed: {result.stderr}", "error")
            return False
        
        log("Changes pushed successfully", "success")
        return True
    
    except subprocess.CalledProcessError as e:
        log(f"Git operation failed: {e}", "error")
        return False

def confirm_action(service: str, action: str, config: Dict) -> bool:
    """Get user confirmation before making changes"""
    log(f"\n{Colors.BOLD}Action Summary:{Colors.ENDC}")
    log(f"  Service: {service}")
    log(f"  Action: {action} (failover to backup)" if action == "promote" else f"  Action: {action} (failback to primary)")
    log(f"  File: {get_deployment_path(config)}")
    log(f"  Namespace: {config.get('namespace')}")
    log(f"  Deployment: {config.get('deployment')}")
    
    while True:
        response = input(f"\n{Colors.BOLD}Proceed? (yes/no): {Colors.ENDC}").strip().lower()
        if response in ['yes', 'y']:
            return True
        elif response in ['no', 'n']:
            return False
        else:
            log("Please enter 'yes' or 'no'", "warning")

def main():
    log("="*60, "header")
    log("GitOps Failover Script", "header")
    log("="*60, "header")
    
    # Load configuration
    log("Loading services configuration...")
    services = load_services_config()
    
    if not services:
        log("No services configured", "error")
        sys.exit(1)
    
    log(f"Found {len(services)} service(s): {', '.join(services.keys())}", "success")
    
    # Interactive menu
    log("\nSelect action:")
    service_list = list(services.keys())
    
    for i, svc in enumerate(service_list, 1):
        print(f"  {i}. {svc}")
    
    while True:
        try:
            choice = int(input(f"\nEnter service number (1-{len(service_list)}): "))
            if 1 <= choice <= len(service_list):
                service = service_list[choice - 1]
                break
            else:
                log(f"Please enter a number between 1 and {len(service_list)}", "warning")
        except ValueError:
            log("Invalid input", "warning")
    
    log(f"\nSelected service: {service}")
    
    # Choose action
    log("\nSelect action:")
    print("  1. Promote (failover to backup)")
    print("  2. Demote (failback to primary)")
    
    while True:
        try:
            action_choice = int(input("\nEnter action number (1-2): "))
            if action_choice == 1:
                action = "promote"
                break
            elif action_choice == 2:
                action = "demote"
                break
            else:
                log("Please enter 1 or 2", "warning")
        except ValueError:
            log("Invalid input", "warning")
    
    service_config = services[service]
    
    # Get configuration details
    if action == "promote":
        source_pvc = service_config.get('primary_pvc')
        target_pvc = service_config.get('backup_pvc')
        target_role = service_config.get('backup_node_label')
    else:
        source_pvc = service_config.get('backup_pvc')
        target_pvc = service_config.get('primary_pvc')
        target_role = service_config.get('primary_node_label')
    
    # Get confirmation
    if not confirm_action(service, action, service_config):
        log("Cancelled by user", "warning")
        sys.exit(0)
    
    # Edit deployment
    deployment_path = get_deployment_path(service_config)
    volume_name = service_config.get('volume_name')
    
    if not edit_deployment(deployment_path, volume_name, source_pvc, target_pvc, target_role):
        log("Failed to edit deployment", "error")
        sys.exit(1)
    
    # Commit and push
    if not git_commit_and_push(service, action):
        log("Failed to commit and push", "error")
        sys.exit(1)
    
    log("\n" + "="*60, "header")
    log("Failover triggered successfully!", "success")
    log("="*60, "header")
    log("\nNext steps:")
    log("1. Flux will detect the change within 1 minute (check 'flux get kustomizations')")
    log("2. Pod will be rescheduled to the target node")
    log("3. Service should become available on the target node")
    log("\nYou can monitor pod status with:")
    log(f"  kubectl get pods -n {service_config.get('namespace')} -o wide --watch")

if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        log("\n\nInterrupted by user", "warning")
        sys.exit(0)
    except Exception as e:
        log(f"Unexpected error: {e}", "error")
        sys.exit(1)
